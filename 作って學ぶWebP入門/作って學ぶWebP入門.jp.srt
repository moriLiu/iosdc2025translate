1
00:00:00,000 --> 00:00:02,520
作って学ぶウェッピー入門

2
00:00:02,520 --> 00:00:07,360
岸川克己

3
00:00:07,360 --> 00:00:18,379
皆さんこんにちは岸川克己です

4
00:00:18,379 --> 00:00:22,739
今日はウェッピーという画像フォーマットの仕組みを皆さんと一緒に学びます

5
00:00:22,739 --> 00:00:27,500
ソフトウェアに限らず何かの原理や仕組みを理解する一番の近道は

6
00:00:27,500 --> 00:00:29,339
実際に作ってみることです

7
00:00:29,339 --> 00:00:34,859
そこで今回はWebPのコーデックを実際にする人で実装しながら

8
00:00:34,859 --> 00:00:37,659
データ構造や圧縮の仕組みについて理解していきます

9
00:00:37,659 --> 00:00:42,719
コーデックというのはエンコーダとデコーダの2つを合わせて呼ぶ言葉です

10
00:00:42,719 --> 00:00:45,979
コーダとデコーダの単語の組み合わせです

11
00:00:45,979 --> 00:00:49,340
作りながら学ぶといっても

12
00:00:49,340 --> 00:00:52,380
ほとんどの人にとってWebPの実装は難しくて

13
00:00:52,380 --> 00:00:55,200
何をしているのかさっぱりわからないということになると思います

14
00:00:55,200 --> 00:01:01,119
そこでこの講演ではそのような学習の障壁を取り除くということを目的にします

15
00:01:01,119 --> 00:01:06,239
Webの実装が難しいというその理由の一つは

16
00:01:06,239 --> 00:01:13,319
まず企画書が基本的に画像フォーマットや圧縮技術について理解しているという前提で書かれていて

17
00:01:13,319 --> 00:01:19,040
その前提知識がなければ企画書からは何をしているのか読み取れないということです

18
00:01:19,040 --> 00:01:23,920
プロトコルの実装なんて企画書に書いてある通りに書いていくだけじゃないかと

19
00:01:23,920 --> 00:01:26,859
最初は私もそう思ってたんですけれども

20
00:01:26,859 --> 00:01:28,859
そうなってはないということです

21
00:01:28,859 --> 00:01:31,459
それならコードを読んでみよう

22
00:01:31,459 --> 00:01:34,060
コードを読めば分かると思っても

23
00:01:34,060 --> 00:01:40,180
参考になるウェッピーの実装は基本的にC言語で書かれたウェッピーぐらいしかなくてですね

24
00:01:40,180 --> 00:01:45,219
この実装だと最適化とか並列処理の分岐とかが

25
00:01:45,219 --> 00:01:48,819
結構本質的な処理以外のところで規模が大きくなっていて複雑なので

26
00:01:48,819 --> 00:01:51,900
学習のために読むにはあんまり向いてないです

27
00:01:51,900 --> 00:01:55,019
そもそも圧縮のアルゴリズムというのは

28
00:01:55,019 --> 00:01:58,219
一般的な方法とはだいぶ異なるので

29
00:01:58,219 --> 00:02:00,700
仕組みを理解できていない段階で読むというのは

30
00:02:00,700 --> 00:02:01,819
だいぶ難しいんですね

31
00:02:01,819 --> 00:02:04,159
なので仕様を読んでもコードを読んでも

32
00:02:04,159 --> 00:02:07,739
何をしているのかつかみにくいというのが

33
00:02:07,739 --> 00:02:09,240
最初の壁となります

34
00:02:09,240 --> 00:02:12,900
その障壁を何とか乗り越えて

35
00:02:12,900 --> 00:02:17,460
企画書を読み解いて実装に取り掛かろうとしたとします

36
00:02:17,460 --> 00:02:21,919
そうであってもよっぽど強いモチベーションでなぎと

37
00:02:21,919 --> 00:02:24,680
すぐに打折することに大体なると思います

38
00:02:24,680 --> 00:02:29,860
というのはベッピーは仕組みとしてはいくつもの小さい工程を重ねて

39
00:02:29,860 --> 00:02:32,280
最終的にサイズが小さくなる仕組み

40
00:02:32,280 --> 00:02:33,379
そういう仕組みなんですね

41
00:02:33,379 --> 00:02:38,240
なので圧縮とか複合のそういう処理は0か1かなんで

42
00:02:38,240 --> 00:02:40,960
正しく実装していても

43
00:02:40,960 --> 00:02:44,699
途中の状態だと全く絵が出たりはしないんですね

44
00:02:44,699 --> 00:02:47,560
なので結果を確認しようと思ったら

45
00:02:47,560 --> 00:02:51,340
一旦その工程を最初から最後まで全部実装する必要があるんですよね

46
00:02:51,340 --> 00:02:54,580
なんですけど各工程はそれぞれ依存している

47
00:02:54,580 --> 00:02:56,939
全工程が後の工程に依存しているので

48
00:02:56,939 --> 00:03:00,900
一つ一つを独立して確かめるっていうのが難しいんです

49
00:03:00,900 --> 00:03:06,120
つまりそれはあまり前が見えない木の中で

50
00:03:06,120 --> 00:03:08,580
長い道のりをずっと歩いていくみたいな感じで

51
00:03:08,580 --> 00:03:11,199
書いているものがこれ合っているのかどうか分からない

52
00:03:11,199 --> 00:03:13,580
これ合っているのかなっていうまま

53
00:03:13,580 --> 00:03:16,599
ずっと全部書いて最後にボーンって確かめる

54
00:03:16,599 --> 00:03:20,080
うまくいかないみたいなことになるんですよね

55
00:03:20,080 --> 00:03:23,419
それを続けられる人はそんなにいないということですね

56
00:03:23,419 --> 00:03:29,740
なのでこの講演ではまず圧縮率とか細かいことは一旦無視して

57
00:03:29,740 --> 00:03:35,259
このFPEの画像としてただ認識されるだけの画像を生成するだけの

58
00:03:35,259 --> 00:03:38,500
ものすごい最小限の実装の円光立てのを最初に作ります

59
00:03:38,500 --> 00:03:44,139
その次にそれをデコードできるデコーダーの方もセットで用意しますね

60
00:03:44,139 --> 00:03:46,900
それをベースに一個ずつ追加していって

61
00:03:46,900 --> 00:03:51,020
一個追加してこっちで画像表示されるとデコードもできると

62
00:03:51,020 --> 00:03:54,979
もう一個追加して同じように確認確認って

63
00:03:54,979 --> 00:03:59,819
それに一個一個実装正しいということを部分的に

64
00:03:59,819 --> 00:04:04,840
段階ステップアイブステップで確認できるような体制を整えて進めていくということをします

65
00:04:04,840 --> 00:04:09,159
そうすると最終的にフル機能のWebPのコーデックができると

66
00:04:09,159 --> 00:04:13,020
そういうことをするために用意したものがあって

67
00:04:13,020 --> 00:04:15,219
この講演で一番大事なのは

68
00:04:15,219 --> 00:04:19,100
そのために用意したサンプルコードと

69
00:04:19,100 --> 00:04:23,899
サンプルコード 最小限の実装というのはサンプルコードとして用意してあって

70
00:04:23,899 --> 00:04:25,699
それとテストデータですね

71
00:04:25,699 --> 00:04:28,100
これが多分一番重要だと思っていて

72
00:04:28,100 --> 00:04:29,980
この話よりもそれが重要で

73
00:04:29,980 --> 00:04:32,180
Suiteで書かれたWebPのコーデックというのは

74
00:04:32,180 --> 00:04:34,180
そもそも世の中になくて

75
00:04:34,180 --> 00:04:35,240
これしかないんですけど

76
00:04:35,240 --> 00:04:39,860
さらに学習用に余計なテクニックとかあまり使わないで

77
00:04:39,860 --> 00:04:42,420
書かれた実装っていうのは本当にこれしかなくて

78
00:04:42,420 --> 00:04:47,040
っていうのでこれは結構いいものができたなっていう感じです

79
00:04:47,040 --> 00:04:51,120
サンプルコードはこのリポジトリで公開しています

80
00:04:51,120 --> 00:04:52,079
多分見れるはず

81
00:04:52,079 --> 00:04:57,300
今回お話しする内容はこちらです

82
00:04:57,300 --> 00:04:59,240
最初にまずはWebP

83
00:04:59,240 --> 00:05:01,199
あまりご存じないこと言うと思うんで

84
00:05:01,199 --> 00:05:02,420
簡単におさらいをします

85
00:05:02,420 --> 00:05:07,980
で、USでWebP使えるのかみたいな話もちょっと触れて

86
00:05:07,980 --> 00:05:10,500
その後はデータ構造とか

87
00:05:10,500 --> 00:05:13,819
紹介しながら実際にファイルを読んでみるとか

88
00:05:13,819 --> 00:05:16,920
あと最小限の実装を

89
00:05:16,920 --> 00:05:19,480
圧縮データを作る

90
00:05:19,480 --> 00:05:21,240
WebPを学ぶ上で必要になる

91
00:05:21,240 --> 00:05:22,839
高データ圧縮に使える技術を

92
00:05:22,839 --> 00:05:24,139
それながら解説します

93
00:05:24,139 --> 00:05:26,519
最後にまとめと次のステップ

94
00:05:26,519 --> 00:05:28,579
これ学んだこととか

95
00:05:28,579 --> 00:05:30,759
これからどういうことをすると楽しいよ

96
00:05:30,759 --> 00:05:31,800
みたいなことをお話しします

97
00:05:31,800 --> 00:05:35,319
ではまずはWEPPについてのおさらいですね

98
00:05:35,319 --> 00:05:36,800
WEPPとはどんなものかと

99
00:05:36,800 --> 00:05:39,600
WEPPはウェブサイトやアプリ上の

100
00:05:39,600 --> 00:05:41,959
障子に適した画像形式です

101
00:05:41,959 --> 00:05:44,740
その適したというのはどういうことかというと

102
00:05:44,740 --> 00:05:46,399
そもそもこの開発の動機が

103
00:05:46,399 --> 00:05:47,759
他のフォーマットよりも

104
00:05:47,759 --> 00:05:49,680
できるだけデータ容量を小さくするということを

105
00:05:49,680 --> 00:05:51,639
目的に最初に開発されているので

106
00:05:51,639 --> 00:05:53,579
それはネットワークを通じて

107
00:05:53,579 --> 00:05:55,120
配信 増受信するということを

108
00:05:55,120 --> 00:05:56,240
想定しているということですね

109
00:05:56,240 --> 00:05:59,720
最初からアルファチャンネルのサポートが

110
00:05:59,720 --> 00:06:02,120
標準であって背景が透過できるとか

111
00:06:02,120 --> 00:06:04,079
あとアニメーションにも対応しているので

112
00:06:04,079 --> 00:06:05,639
アイコンとか

113
00:06:05,639 --> 00:06:08,759
UIの要素にも使いやすいような

114
00:06:08,759 --> 00:06:10,920
フォーマットになっているということです

115
00:06:10,920 --> 00:06:12,620
ここまでは

116
00:06:12,620 --> 00:06:15,120
わりと知っている方も多いと思うんですが

117
00:06:15,120 --> 00:06:17,920
意外とWEPに知られていなかったなという特徴として

118
00:06:17,920 --> 00:06:19,259
過逆圧縮と

119
00:06:19,259 --> 00:06:21,620
非過逆圧縮の両方をサポートしている

120
00:06:21,620 --> 00:06:22,420
ということがあります

121
00:06:22,420 --> 00:06:24,939
モバイルアプリで使う分には

122
00:06:24,939 --> 00:06:26,639
だいたいPNGの

123
00:06:26,639 --> 00:06:27,540
代替みたいに

124
00:06:27,540 --> 00:06:29,120
使うことが多いと思うので

125
00:06:29,120 --> 00:06:32,939
可逆圧縮でPNGよりも小さくなるという風に

126
00:06:32,939 --> 00:06:36,639
多分そういう風に知っている人もいると思うんですけど

127
00:06:36,639 --> 00:06:41,480
実際にはJPEGのような非可逆圧縮も使うことができます

128
00:06:41,480 --> 00:06:46,199
実際には非可逆圧縮のロッシーフォーマットの方が

129
00:06:46,199 --> 00:06:48,360
使われている方が多いと思います

130
00:06:48,360 --> 00:06:52,160
ほとんどのWebP関連のツールでも

131
00:06:52,160 --> 00:06:54,819
こっちの方がデータ量が小さくなるので

132
00:06:54,819 --> 00:06:58,800
デフォルトにはロッシー形式になっていることが多いはずです

133
00:06:58,800 --> 00:07:03,639
なのでWebPだから品質劣化しないというふうな思い込みでやっていると

134
00:07:03,639 --> 00:07:08,339
ツールからPNGで変換すると実はロッシーになっているみたいなことはあったりするので

135
00:07:08,339 --> 00:07:10,040
ここはちょっと落とし合いのかもしれませんね

136
00:07:10,040 --> 00:07:15,420
まとめるとWebPはウェブとかアプリの配信用に

137
00:07:15,420 --> 00:07:19,180
データ容量をできるだけ小さくするということを目的に作られていて

138
00:07:19,180 --> 00:07:22,680
ロッシー形式もあるので写真とかにも使えるし

139
00:07:22,680 --> 00:07:25,100
ロッスレス形式だったらイラストとかアイコンに向いているので

140
00:07:25,100 --> 00:07:29,879
だいたいいろんなほぼ全ての種類の画像に使うことができて

141
00:07:29,879 --> 00:07:33,139
ロスレストロッシーの2つの圧縮モードがあるっていう

142
00:07:33,139 --> 00:07:36,899
だいたいこれぐらいが知っていれば大きいかなって感じです

143
00:07:36,899 --> 00:07:41,180
EOSでのサポート状況ですけど

144
00:07:41,180 --> 00:07:44,540
これはIOS14以降からだったらだいたい使えます

145
00:07:44,540 --> 00:07:47,879
だいたいというかほぼ完璧に使えると思います

146
00:07:47,879 --> 00:07:50,779
Safari WebViewでウェブ表示の採用ができるし

147
00:07:50,779 --> 00:07:53,319
ネイティブアプリケーションから操作するんだったら

148
00:07:53,319 --> 00:07:55,339
CGイメージソースを使ったら

149
00:07:55,339 --> 00:07:58,579
1枚の静止画もアニメーションもどっちも読み込むことができます

150
00:07:58,579 --> 00:08:01,180
静止画だけでいいんだったら

151
00:08:01,180 --> 00:08:04,740
UIイメージのイニシャライザーで直接インサンス化することもできます

152
00:08:04,740 --> 00:08:07,540
エンコードは対応してないですね

153
00:08:07,540 --> 00:08:09,220
PNGは作れるんですけど

154
00:08:09,220 --> 00:08:13,279
WebPをiOSとかMacで作るってことは標準ではできないです

155
00:08:13,279 --> 00:08:15,439
ということで

156
00:08:15,439 --> 00:08:18,740
WebPの内部について見ていこうと思います

157
00:08:18,740 --> 00:08:22,420
最初はセオリー通りデータ構造を見ていくことにしましょう

158
00:08:22,420 --> 00:08:26,079
一般的なデータフォーマットとは一緒で

159
00:08:26,079 --> 00:08:28,399
WebPもヘッダーとデータに分かれています

160
00:08:28,399 --> 00:08:30,100
ヘッダーはデータの種類とか

161
00:08:30,100 --> 00:08:31,839
サイズとかのメタデータが入っていて

162
00:08:31,839 --> 00:08:34,539
実際の画像はデータ部分に入っているという構造ですね

163
00:08:34,539 --> 00:08:38,220
WebPにおいてヘッダーとデータは

164
00:08:38,220 --> 00:08:40,879
設計はWebP独自のものとかじゃなくて

165
00:08:40,879 --> 00:08:43,019
他のファイルフォーマットでも使われている

166
00:08:43,019 --> 00:08:46,960
RIF リソースインターチェンジファイルフォーマットというものが使われています

167
00:08:46,960 --> 00:08:50,899
RIFというのは汎用的なデータフォーマットなので

168
00:08:50,899 --> 00:08:55,620
任意のデータを格納できるシンプルな入れ物みたいな感じで設計されています

169
00:08:55,620 --> 00:09:02,299
なのでリフの一番トップレベルの構造はリフコンテナーみたいに呼ぶこともあります

170
00:09:02,299 --> 00:09:09,139
リフの構造はチャンクと呼ばれるデータのグループで構成されていまして

171
00:09:09,139 --> 00:09:13,139
一つのリフコンテナーでは複数のチャンクを持つことができます

172
00:09:13,139 --> 00:09:20,659
チャンクの構造は先頭に4キャラクターコード4CCと呼ばれるデータの種類を示すまずIDが入ります

173
00:09:20,659 --> 00:09:24,340
4CCはアルファベット4文字で表すので

174
00:09:24,340 --> 00:09:25,200
こういうふうに呼ばれます

175
00:09:25,200 --> 00:09:26,879
4キャラクターコですね

176
00:09:26,879 --> 00:09:32,419
次にチャンク本体のデータのサイズが続きますと

177
00:09:32,419 --> 00:09:34,299
まず先頭のチャンクは

178
00:09:34,299 --> 00:09:37,340
これリフファイルだったらリフコンテナ自体を示すので

179
00:09:37,340 --> 00:09:40,519
これは必ずRIFFというものが入っていて

180
00:09:40,519 --> 00:09:42,340
リフというIDが入ります

181
00:09:42,340 --> 00:09:44,360
WebPだけじゃなくて

182
00:09:44,360 --> 00:09:47,259
このリフコンテナを採用しているファイルフォーマットは

183
00:09:47,259 --> 00:09:50,519
全てリフで始まることになります

184
00:09:50,519 --> 00:09:53,440
次に実際のデータ部分のサイズが入って

185
00:09:53,440 --> 00:09:56,519
例えばチャンクが1個しかない場合だと

186
00:09:56,519 --> 00:09:58,960
全体のサイズが100バイトだったら

187
00:09:58,960 --> 00:10:01,940
このサイズにはこのヘッダーのリフと

188
00:10:01,940 --> 00:10:05,100
自身のファイルサイズが入っている部分の容量を除いて

189
00:10:05,100 --> 00:10:07,580
92バイトというのが入ることになります

190
00:10:07,580 --> 00:10:11,360
WebPファイルの場合は

191
00:10:11,360 --> 00:10:13,360
このリフチャンクのペイロードは

192
00:10:13,360 --> 00:10:16,500
WebPファイルを示すOCCのIDが入ることになるので

193
00:10:16,500 --> 00:10:19,779
これはWEBPの自身の名前ですね

194
00:10:19,779 --> 00:10:21,399
これがIDそのまま入ります

195
00:10:21,399 --> 00:10:27,679
ここまで読んだらこのファイルがWebPのフォーマットなんだなということが分かるんですね

196
00:10:27,679 --> 00:10:33,779
先頭からWEBPまでのこの4Cシマのこの12バイトの部分を

197
00:10:33,779 --> 00:10:35,960
WebPヘッダーということもあります

198
00:10:35,960 --> 00:10:43,240
ここからはWebPフォーマットの規格を知って読んでいくみたいな感じになります

199
00:10:43,240 --> 00:10:48,940
そうするとWebPがどういう機能をサポートしているのかというのを

200
00:10:48,940 --> 00:10:50,879
画像形式とかどんな機能があるかというのを

201
00:10:50,879 --> 00:10:51,960
抑えていく必要が出てきます

202
00:10:51,960 --> 00:10:55,000
さっき話したようにWebPは標準で

203
00:10:55,000 --> 00:10:57,820
ロッシーとロスレス形式の2種類のサポートがあるので

204
00:10:57,820 --> 00:11:01,259
少なくとも2種類のデータが入ってくることが分かります

205
00:11:01,259 --> 00:11:03,600
アニメーションが使われている場合は

206
00:11:03,600 --> 00:11:06,299
複数の画像データが入っていることになって

207
00:11:06,299 --> 00:11:08,659
それぞれの画像データのアニメーションのフレームには

208
00:11:08,659 --> 00:11:10,779
ロッシーとロスレスを混ぜることもできます

209
00:11:10,779 --> 00:11:13,559
Exifとかカラープロファイルみたいな

210
00:11:13,559 --> 00:11:16,559
メタデータを保持するようなこともサポートしています

211
00:11:16,559 --> 00:11:20,639
例えばロッシー形式の静止画の入っている場合は

212
00:11:20,639 --> 00:11:24,940
その次にチャンクヘッダーにVP8スペースになります

213
00:11:24,940 --> 00:11:28,240
4CCはアルファエット4文字で決まっているので

214
00:11:28,240 --> 00:11:30,659
これ最後はスペースが絶対入ることになります

215
00:11:30,659 --> 00:11:31,940
3文字って言うのダメなんで

216
00:11:31,940 --> 00:11:35,320
VP8スペースまでが正式な4CCですね

217
00:11:35,320 --> 00:11:40,419
ロッセレス形式は4CCがVP8Lになります

218
00:11:40,419 --> 00:11:45,460
チャンクサイズは全体からココアのヘッダーのサイズで引いて

219
00:11:45,460 --> 00:11:48,159
この場合だと80バイトが入ってますね

220
00:11:48,159 --> 00:11:50,059
続くチャンクペロードに

221
00:11:50,059 --> 00:11:52,240
圧縮された画像データ本体が入ってきます

222
00:11:52,240 --> 00:11:54,899
こういうチャンクが1個しかない

223
00:11:54,899 --> 00:11:56,320
WebPフォーマットを

224
00:11:56,320 --> 00:11:59,440
WebPではシンプルファイルフォーマットと呼びます

225
00:11:59,440 --> 00:12:02,019
ロシーとロスレスは

226
00:12:02,019 --> 00:12:05,240
圧縮の方法もいろんな扱いも全然違って

227
00:12:05,240 --> 00:12:06,960
共通の部分は全くないと

228
00:12:06,960 --> 00:12:08,159
同じ処理は全然できないので

229
00:12:08,159 --> 00:12:09,799
デコーダーの実装だと

230
00:12:09,799 --> 00:12:11,279
チャンクヘッダーを見て

231
00:12:11,279 --> 00:12:14,679
処理を完全に2つに分岐するみたいな実装になります

232
00:12:14,679 --> 00:12:19,679
WebPを実装が大変な理由のもう一つとしては

233
00:12:19,679 --> 00:12:21,299
このフル機能を実装としようとしたら

234
00:12:21,299 --> 00:12:23,240
このロッシーとロッスレスで

235
00:12:23,240 --> 00:12:24,340
もう全く違う

236
00:12:24,340 --> 00:12:28,200
基本的に2種類の別のソフトウェアを書くみたいなことになるので

237
00:12:28,200 --> 00:12:31,740
その辺も大変ということになりますね

238
00:12:31,740 --> 00:12:35,179
Exifメタデータを含めたり

239
00:12:35,179 --> 00:12:36,299
アニメーションを使う場合は

240
00:12:36,299 --> 00:12:38,759
シンプルファイルフォーマットじゃ収まらないので

241
00:12:38,759 --> 00:12:41,379
エクステンデッドファイルフォーマットというものになります

242
00:12:41,379 --> 00:12:43,600
エクステンデッドファイルフォーマットでは

243
00:12:43,600 --> 00:12:49,440
4CCがVP8Xっていう固定帳10バイトのチャンクを持つものを配置して

244
00:12:49,440 --> 00:12:55,100
それが来ると続きがメタデータとかアニメーションの情報も入っているなということが分かります

245
00:12:55,100 --> 00:12:59,419
このVP8Xには各機能のどれが使われているかっていう

246
00:12:59,419 --> 00:13:01,860
フラグがこの10バイトの中に入っているんですね

247
00:13:01,860 --> 00:13:07,539
そのフラグが有効な機能の場合は普通はそのに関するデータがチャンクとして入ってくると

248
00:13:07,539 --> 00:13:12,440
Exifとかはレンダリングに影響しないんでどこに書いてもいいんですけど

249
00:13:12,440 --> 00:13:15,500
プロファイルとかアニメーションとかアルファは

250
00:13:15,500 --> 00:13:20,120
順番に基本的に先頭の方に置いとかなきゃいけない

251
00:13:20,120 --> 00:13:23,960
画像データの前にないといけないみたいなルールがあります

252
00:13:23,960 --> 00:13:30,120
アニメーション機能を例えばフラグで有効にしてないのに

253
00:13:30,120 --> 00:13:31,620
アニメーションチャンクが来るとか

254
00:13:31,620 --> 00:13:37,659
その他全然関係ないIDのチャンクが入って書いてあったとしても

255
00:13:37,659 --> 00:13:39,899
これは基本的に無視されます

256
00:13:39,899 --> 00:13:42,919
こういうのはアンノンチャンクとして扱うことになっていて

257
00:13:42,919 --> 00:13:45,200
エラーにはならないということに基本的にはなっています

258
00:13:45,200 --> 00:13:50,820
これを利用して任意のデータをファイルに載せるみたいなことも

259
00:13:50,820 --> 00:13:52,500
一応できることになっています

260
00:13:52,500 --> 00:13:54,600
ということでですね

261
00:13:54,600 --> 00:13:59,080
最初の第一歩としてデータ以外のヘッダー部分を読むというのをやってみましょうと

262
00:13:59,080 --> 00:14:04,419
見てきたように画像データ以外の情報は

263
00:14:04,419 --> 00:14:07,639
リフフォーマットの構造になっているので

264
00:14:07,639 --> 00:14:09,639
4バイトの4CCがあって

265
00:14:09,639 --> 00:14:11,080
サイズが4バイトあって

266
00:14:11,080 --> 00:14:13,740
次チャンクデータが来るんで

267
00:14:13,740 --> 00:14:16,779
その読んだサイズの分だけ飛ばして

268
00:14:16,779 --> 00:14:18,120
データが続いているのだったら

269
00:14:18,120 --> 00:14:20,659
さらに同じように4バイト4ccと

270
00:14:20,659 --> 00:14:22,200
順番に読んでいけばOKです

271
00:14:22,200 --> 00:14:24,159
つまりヘッダー読むっていうのは

272
00:14:24,159 --> 00:14:25,799
画像データの部分だけ飛ばして

273
00:14:25,799 --> 00:14:27,139
ヘッダーだけ読んでいくって感じですね

274
00:14:27,139 --> 00:14:28,940
これだけ読むんだったら

275
00:14:28,940 --> 00:14:30,179
生のバイトが入っているんで

276
00:14:30,179 --> 00:14:32,100
圧縮データの複合とかしないので

277
00:14:32,100 --> 00:14:33,080
すごい簡単なので

278
00:14:33,080 --> 00:14:34,360
でもこれだけでも

279
00:14:34,360 --> 00:14:37,059
WebPファイルがロッシーかロッスレスかとか

280
00:14:37,059 --> 00:14:38,200
アニメーションが入っているかどうか

281
00:14:38,200 --> 00:14:40,620
みたいな情報が取れるっていうことです

282
00:14:40,620 --> 00:14:43,539
Rifヘッダーリーダーは

283
00:14:43,539 --> 00:14:44,840
だからこんな感じになって

284
00:14:44,840 --> 00:14:46,399
なります

285
00:14:46,399 --> 00:14:48,559
これはRifヘッダーリーダーで

286
00:14:48,559 --> 00:14:49,460
っていう名前で

287
00:14:49,460 --> 00:14:50,960
サンプルコードに入ってるんで

288
00:14:50,960 --> 00:14:52,980
これを使って

289
00:14:52,980 --> 00:14:55,379
バイナリー操作とかあんまり書いたことないんだったら

290
00:14:55,379 --> 00:14:57,899
一旦入門としてこれとかやってみたり

291
00:14:57,899 --> 00:15:00,240
WebPファイルをいろいろ読み込ませてみて

292
00:15:00,240 --> 00:15:02,500
あーって思う感じで

293
00:15:02,500 --> 00:15:04,500
楽しめるんじゃないかなと思います

294
00:15:04,500 --> 00:15:09,679
いよいよ画像データの中身を見ていくということになります

295
00:15:09,679 --> 00:15:12,360
最初に話したようにですね

296
00:15:12,360 --> 00:15:17,779
WebPの画像データは何もそのことを何も知らないで読めるものではないので

297
00:15:17,779 --> 00:15:18,840
ないんですね

298
00:15:18,840 --> 00:15:21,539
複数段階の圧縮と変換がかかっていて

299
00:15:21,539 --> 00:15:26,200
そのまま読んで読める生のビットというのがほとんどないんですね

300
00:15:26,200 --> 00:15:29,460
なのでまず1種類の処理だけを

301
00:15:29,460 --> 00:15:32,980
変換処理だけを補足しただけのWebP画像を自分で作ります

302
00:15:32,980 --> 00:15:36,419
なんで自分で作るかというと

303
00:15:36,419 --> 00:15:38,139
理解するためというのもあるんですけど

304
00:15:38,139 --> 00:15:39,399
そんなデータは世の中に

305
00:15:39,399 --> 00:15:40,980
そういうWEPファイルないからですね

306
00:15:40,980 --> 00:15:44,120
LubFPのテストデータには

307
00:15:44,120 --> 00:15:46,980
そういう処理を確認するための

308
00:15:46,980 --> 00:15:50,019
この変換を施したものみたいな

309
00:15:50,019 --> 00:15:51,620
テストデータもあるんですけど

310
00:15:51,620 --> 00:15:53,759
それをデコードするにも

311
00:15:53,759 --> 00:15:55,179
やっぱりそこそこの実装が必要で

312
00:15:55,179 --> 00:15:57,419
本当に最小限のテストデータというのはないんですよ

313
00:15:57,419 --> 00:15:59,700
なので自分で作ることになります

314
00:15:59,700 --> 00:16:02,559
どういうデータを作るのか

315
00:16:02,559 --> 00:16:04,779
仕様から考えていくと

316
00:16:04,779 --> 00:16:07,779
ロッシーかロスレスか

317
00:16:07,779 --> 00:16:09,639
あとアニメーションの場合は

318
00:16:09,639 --> 00:16:12,220
ロッシーかロスレスの複数のデータが入ってくると

319
00:16:12,220 --> 00:16:13,600
感じですね

320
00:16:13,600 --> 00:16:18,179
まずメタデータは圧縮複合に今回は関係ないので

321
00:16:18,179 --> 00:16:20,000
一旦対象外と

322
00:16:20,000 --> 00:16:23,179
アニメーションも各フレームについては

323
00:16:23,179 --> 00:16:25,100
静止画と基本的には一緒なんで

324
00:16:25,100 --> 00:16:26,960
今回は対象外と

325
00:16:26,960 --> 00:16:30,480
ただアニメーションは背景だけを分離したりとか

326
00:16:30,480 --> 00:16:35,059
変わった部分だけを書き込むとか

327
00:16:35,059 --> 00:16:39,039
そういうアニメーション特有差分だけ書き込むみたいな機能があるので

328
00:16:39,039 --> 00:16:43,559
一応追加の実装がアニメーションにちゃんと対応するには必要だったりします

329
00:16:43,559 --> 00:16:47,299
ということでサンプルコードでは

330
00:16:47,299 --> 00:16:50,960
αを含むロッシーとロッスレス形式の両方の

331
00:16:50,960 --> 00:16:53,700
レコードデンコードに対応しています最終的には

332
00:16:53,700 --> 00:16:56,980
ロッスレスには常にαがあります

333
00:16:56,980 --> 00:16:59,720
シンプルファイルフォーマットに対応していて

334
00:16:59,720 --> 00:17:02,340
あと拡張形式はαが読めるということですね

335
00:17:02,340 --> 00:17:07,559
この時間ではロスレス形式について話します

336
00:17:07,559 --> 00:17:11,920
ロッシーに比べてロスレスは一つ一つの工程がシンプルで

337
00:17:11,920 --> 00:17:13,279
多分分かりやすいので

338
00:17:13,279 --> 00:17:18,200
データの変換については入力としているか分かりやすいので

339
00:17:18,200 --> 00:17:20,740
この最小限のデータというのがあれば

340
00:17:20,740 --> 00:17:23,839
結構これを段階的に進めていくのはそんなに難しくないからですね

341
00:17:23,839 --> 00:17:29,000
ということでVP8Lのデータ構造を見ていきます

342
00:17:29,000 --> 00:17:33,839
一般的にWIPPのデータ分はビットストリームといいます

343
00:17:33,839 --> 00:17:37,859
ビットストリームの先頭にはVP8Lのヘッダーがあります

344
00:17:37,859 --> 00:17:42,140
これは固定の値が入っていて

345
00:17:42,140 --> 00:17:45,559
次に幅と高さが来て

346
00:17:45,559 --> 00:17:47,880
アルファの有無でバージョンが入ってきます

347
00:17:47,880 --> 00:17:52,039
VP8Lロスレスデータの場合は

348
00:17:52,039 --> 00:17:53,539
アルファはデータに必ずあるので

349
00:17:53,539 --> 00:17:55,880
これはもう読んでもらえなくてどっちもいいです

350
00:17:55,880 --> 00:18:00,559
なので基本的に幅と高さだけが必要な情報ですね

351
00:18:00,559 --> 00:18:03,039
バージョンの値も今は0が入っているので

352
00:18:03,039 --> 00:18:04,519
入っています

353
00:18:04,519 --> 00:18:05,880
読み飛ばしてもいいんですけど

354
00:18:05,880 --> 00:18:07,880
基本的にこれ異なる値が来た場合は

355
00:18:07,880 --> 00:18:09,660
ここは不正なデータということで

356
00:18:09,660 --> 00:18:11,500
エラーにすることが多いです

357
00:18:11,500 --> 00:18:14,960
ビットストリームという通りですね

358
00:18:14,960 --> 00:18:17,240
このデータはビット単位に読む必要があります

359
00:18:17,240 --> 00:18:21,559
これ高さと幅はそもそもバイト境界にまたいでいますね

360
00:18:21,559 --> 00:18:25,579
別品は1ビットでもファイズを小さくしたいということがあるので

361
00:18:25,579 --> 00:18:29,539
ビット単位で限界まで詰めて書かれているってことになります

362
00:18:29,539 --> 00:18:35,079
プログラミング言語は大抵はビット単位で読むっていう機能はないので

363
00:18:35,079 --> 00:18:36,759
これは作る必要があります

364
00:18:36,759 --> 00:18:41,140
やってることはバイト単位で読んだデータを

365
00:18:41,140 --> 00:18:43,819
ビットシルトで必要なビットだけ取り出して

366
00:18:43,819 --> 00:18:46,759
足りなくなったら1倍と読むっていう感じになります

367
00:18:46,759 --> 00:18:51,039
ヘッダーのデータはそのまま読める生のビットなんで

368
00:18:51,039 --> 00:18:54,140
ビットを読むこういう処理だけ作ったら

369
00:18:54,140 --> 00:18:55,359
減った部分は読めて

370
00:18:55,359 --> 00:18:57,640
これで何が分かるかというと

371
00:18:57,640 --> 00:19:00,059
縦横のサイズが分かるということですね

372
00:19:00,059 --> 00:19:03,299
縦横のサイズというのは

373
00:19:03,299 --> 00:19:06,259
結構画像の処理をする上では重要で

374
00:19:06,259 --> 00:19:08,200
というのも画像データというのは

375
00:19:08,200 --> 00:19:10,200
目で見る場合は四角形をしているんですけど

376
00:19:10,200 --> 00:19:11,680
ソフトウェアの上では

377
00:19:11,680 --> 00:19:15,440
メモリ上で連続した1次元の配列としてくるんですね

378
00:19:15,440 --> 00:19:19,980
画像圧縮する手法というのは

379
00:19:19,980 --> 00:19:23,019
結構近くのピクセルは色が似ているとか

380
00:19:23,019 --> 00:19:27,460
そういう推測を利用することが多いんですけど

381
00:19:27,460 --> 00:19:28,700
その場合ですね

382
00:19:28,700 --> 00:19:30,460
メモリ上で隣にあるからといって

383
00:19:30,460 --> 00:19:33,259
実際の画像では端と端って場合があるわけですよね

384
00:19:33,259 --> 00:19:36,339
逆にメモリ上で離れているからといって

385
00:19:36,339 --> 00:19:40,640
画像では上下で隣同士みたいなことはあるんですよ

386
00:19:40,640 --> 00:19:43,980
なので縦横のサイズっていうのは重要なんで

387
00:19:43,980 --> 00:19:45,119
大抵のフォーマットでは

388
00:19:45,119 --> 00:19:47,559
実際のピクセルを読む前に分かるように

389
00:19:47,559 --> 00:19:49,460
先頭の方にあることが多いですね

390
00:19:49,460 --> 00:19:51,599
ちょっと後ろにあるフォーマットもありますけどね

391
00:19:51,599 --> 00:19:56,140
ヘッダー以降は圧縮された画像データが入っていて

392
00:19:56,140 --> 00:19:58,579
これはもう本当に生のビットじゃないんで

393
00:19:58,579 --> 00:20:00,420
何かしないと読めないです

394
00:20:00,420 --> 00:20:03,859
データを圧縮する工程はロスレスデータだと

395
00:20:03,859 --> 00:20:05,019
こんな感じで

396
00:20:05,019 --> 00:20:08,680
3種類から6種類の工程もっとかな

397
00:20:08,680 --> 00:20:11,119
減って出来上がるんで

398
00:20:11,119 --> 00:20:14,039
これが障壁で

399
00:20:14,039 --> 00:20:15,799
各工程の概念については

400
00:20:15,799 --> 00:20:17,980
企画書では全然書いてなくて

401
00:20:17,980 --> 00:20:19,319
手順は書いてるんですけど

402
00:20:19,319 --> 00:20:20,539
どういうものか書いてないんで

403
00:20:20,539 --> 00:20:25,039
これ知らないとこれ何やってるか基本的に分からないということになります

404
00:20:25,039 --> 00:20:28,059
復元はこれ逆をやるんですけど

405
00:20:28,059 --> 00:20:31,240
どっちにしろ知らないとどっちも書けないですね

406
00:20:31,240 --> 00:20:34,460
だからね工程の知識が必要ってことになります

407
00:20:34,460 --> 00:20:41,920
結局これを一つずつ理解していきたいんですけど

408
00:20:41,920 --> 00:20:44,420
普通にやったらそれ難しいんで

409
00:20:44,420 --> 00:20:48,980
ここでは1個だけを実装したまずコーディックと

410
00:20:48,980 --> 00:20:50,519
そのデータっていうのを用意して

411
00:20:50,519 --> 00:20:53,500
それでまず最初の検証ができるんで

412
00:20:53,500 --> 00:20:57,339
その後が続けていけるっていうアプローチを取ります

413
00:20:57,339 --> 00:21:00,720
これサンプルコードとして公開してる

414
00:21:00,720 --> 00:21:02,339
さっき紹介したパッケージ

415
00:21:02,339 --> 00:21:04,420
これそれぞれがどの工程に対してるか

416
00:21:04,420 --> 00:21:06,160
基本名前のついてるものが

417
00:21:06,160 --> 00:21:09,920
その名前の圧縮工程に対応しています

418
00:21:09,920 --> 00:21:14,640
このBitStreamは最終的には

419
00:21:14,640 --> 00:21:16,380
このプレフィックスコーディングっていう

420
00:21:16,380 --> 00:21:18,900
圧縮手法を使って変更されるんで

421
00:21:18,900 --> 00:21:22,180
プレフィックスコーディングだけはもう絶対通るようになっています

422
00:21:22,180 --> 00:21:28,059
それ以外のことは基本的に1個だけそれぞれのパッケージで

423
00:21:28,059 --> 00:21:30,099
その1個だけが実装している感じになります

424
00:21:30,099 --> 00:21:36,299
この8番目のやつはフル機能のデコーダー エンコーダーという感じですね

425
00:21:36,299 --> 00:21:39,700
ということでこれ見てきたように

426
00:21:39,700 --> 00:21:42,940
必須の工程というのがプレフィックスコーディングなんですね

427
00:21:42,940 --> 00:21:45,599
なのでまずプレフィックスコーディングというのを実装してみます

428
00:21:45,599 --> 00:21:48,640
世の中にはプレフィックスコーディングだけが

429
00:21:48,640 --> 00:21:50,759
行われたWebP画像というのはないので

430
00:21:50,759 --> 00:21:53,759
本当にまず最初にこれを作るというのが

431
00:21:53,759 --> 00:21:55,220
一番ベースになります

432
00:21:55,220 --> 00:21:58,180
プレフィックスコーディングというよりも

433
00:21:58,180 --> 00:21:59,420
多分ハフマンコーディングとか

434
00:21:59,420 --> 00:22:00,799
ハフマン不合化といった方が

435
00:22:00,799 --> 00:22:02,339
耳なじみがあると思います

436
00:22:02,339 --> 00:22:05,680
ただWebPの企画書には

437
00:22:05,680 --> 00:22:08,259
ハフマン不合化という言葉は全く同時しなくて

438
00:22:08,259 --> 00:22:10,299
全てプレフィックスコーディングと書いてますね

439
00:22:10,299 --> 00:22:13,299
用語は厳密に整理するとこんな感じで

440
00:22:13,299 --> 00:22:14,519
プレフィックスコーディングの

441
00:22:14,519 --> 00:22:16,619
ハフマンコーディングがプレフィックスコーディングの一種で

442
00:22:16,619 --> 00:22:17,740
みたいな感じなんですけど

443
00:22:17,740 --> 00:22:21,420
Web PEではハフマンコーディングが常に

444
00:22:21,420 --> 00:22:22,920
カノニカルハフマンコーディングで

445
00:22:22,920 --> 00:22:26,259
それが全部プレフィックスコーディングと呼ばれているので

446
00:22:26,259 --> 00:22:31,059
この講演でもハフマンコーディングといったら

447
00:22:31,059 --> 00:22:33,799
カノニカルハフマンコーディングのことを指すみたいな感じで

448
00:22:33,799 --> 00:22:35,099
一旦ここで整理しておきます

449
00:22:35,099 --> 00:22:40,019
まず一般的なハフマン法から説明します

450
00:22:40,019 --> 00:22:44,079
圧縮というのはどういうことか処理かというと

451
00:22:44,079 --> 00:22:45,759
データにある冗長性を

452
00:22:45,759 --> 00:22:48,180
短い表現に置き換えることです

453
00:22:48,180 --> 00:22:50,000
冗長性にはいろいろあるんですけど

454
00:22:50,000 --> 00:22:51,640
ハークマンコーディングでは

455
00:22:51,640 --> 00:22:54,180
統計的な偏りを利用します

456
00:22:54,180 --> 00:22:55,460
よく出る値と

457
00:22:55,460 --> 00:22:57,440
そんなに出ない値というのを

458
00:22:57,440 --> 00:22:58,700
偏りに注目します

459
00:22:58,700 --> 00:23:01,180
よく出る値

460
00:23:01,180 --> 00:23:03,299
出現頻度の高いシンボルに

461
00:23:03,299 --> 00:23:05,200
短い記号を割り当てて

462
00:23:05,200 --> 00:23:06,740
出現頻度の低い

463
00:23:06,740 --> 00:23:09,960
ヒンボルに長い符号を割り当てるというのが

464
00:23:09,960 --> 00:23:11,359
ハークマン保護化です

465
00:23:11,359 --> 00:23:13,839
いきなり画像データを

466
00:23:13,839 --> 00:23:15,660
符号化する前に

467
00:23:15,660 --> 00:23:18,519
一旦簡単な文字列を使った例でやります

468
00:23:18,519 --> 00:23:19,980
ブックキーパーという単語を

469
00:23:19,980 --> 00:23:22,319
ハフマン符号化するとすると

470
00:23:22,319 --> 00:23:25,420
まず手順は文字の出現頻度を数えます

471
00:23:25,420 --> 00:23:26,599
Eが3回

472
00:23:26,599 --> 00:23:27,440
OとKが2回

473
00:23:27,440 --> 00:23:29,319
BPRが1回ずつですね

474
00:23:29,319 --> 00:23:32,220
これを表にまとめて頻度の順に並べて

475
00:23:32,220 --> 00:23:33,759
左の方が高頻度ですね

476
00:23:33,759 --> 00:23:35,119
これ偏りがあるので

477
00:23:35,119 --> 00:23:38,619
これ冗長性があるので圧縮できるということです

478
00:23:38,619 --> 00:23:41,200
よく出てくる文字ほど短い符号で

479
00:23:41,200 --> 00:23:44,019
あまり使われない文字を長く表すと

480
00:23:44,019 --> 00:23:46,140
手順はこちらで

481
00:23:46,140 --> 00:23:48,960
これは手順を読むより見たほうが早いので

482
00:23:48,960 --> 00:23:51,160
実際に見ていきましょう

483
00:23:51,160 --> 00:23:54,660
まず頻度表からそのまま

484
00:23:54,660 --> 00:23:57,619
葉っぱリーフの濃度を作ります

485
00:23:57,619 --> 00:23:59,720
これを写しただけですね

486
00:23:59,720 --> 00:24:03,279
一番頻度の低いシンボルの2つを取り出して

487
00:24:03,279 --> 00:24:05,240
二分岐を作りますと

488
00:24:05,240 --> 00:24:06,299
これを繰り返します

489
00:24:06,299 --> 00:24:10,339
親の濃度は葉の濃度の頻度の合計が入ります

490
00:24:10,339 --> 00:24:14,480
親濃度はもうマージする対象になります

491
00:24:14,480 --> 00:24:20,759
同じように残った2つを取り出して木を作ります

492
00:24:20,759 --> 00:24:22,839
次同じ処理を繰り返すんですけど

493
00:24:22,839 --> 00:24:26,259
これは3より親濃度の2の方が低いので

494
00:24:26,259 --> 00:24:29,619
このOの2と親濃度の2というのがマージする対象になって

495
00:24:29,619 --> 00:24:31,920
こうマージされて

496
00:24:31,920 --> 00:24:37,740
あとは同じように1本の木になるまで繰り返していくと

497
00:24:37,740 --> 00:24:39,900
1本の木になるまで繰り返して

498
00:24:39,900 --> 00:24:42,500
こうすると1本の木ができるので

499
00:24:42,500 --> 00:24:47,259
最初の木はこのようになって

500
00:24:47,259 --> 00:24:50,799
これのことをハフマンツリーとかハフマンギと言います

501
00:24:50,799 --> 00:24:53,539
ハフマンギができたら

502
00:24:53,539 --> 00:24:56,279
右左左に0右の枝に1

503
00:24:56,279 --> 00:24:57,180
これ逆でもいいですけど

504
00:24:57,180 --> 00:25:00,859
左に0右の枝に1っていうのを割り当てて

505
00:25:00,859 --> 00:25:03,779
あとこれルートからたどると符号ができます

506
00:25:03,779 --> 00:25:08,140
Eだったら左左なんで00っていう符号になります

507
00:25:08,140 --> 00:25:11,980
Oは右左なんで10

508
00:25:11,980 --> 00:25:16,380
Kは左右左なんで010っていう符号になって

509
00:25:16,380 --> 00:25:18,480
こうすると符号が確定しますと

510
00:25:18,480 --> 00:25:22,259
頻度の高いものが短い符号になっています

511
00:25:22,259 --> 00:25:23,279
という感じですね

512
00:25:23,279 --> 00:25:26,579
符号を使ってブックキーパーの文字列を置き換えると

513
00:25:26,579 --> 00:25:29,720
こういうふうに表現できて25ビットになるんですね

514
00:25:29,720 --> 00:25:33,279
これAからZまで文字書があるとすると

515
00:25:33,279 --> 00:25:35,859
1文字あたりを表すには5ビット必要なんで

516
00:25:35,859 --> 00:25:38,380
5×10文字で50ビット必要だったものが

517
00:25:38,380 --> 00:25:39,380
25ビットになったので

518
00:25:39,380 --> 00:25:40,819
50%圧縮されたと

519
00:25:40,819 --> 00:25:42,660
この原理になります

520
00:25:42,660 --> 00:25:46,579
ちょっと気づいた人もいるかもしれませんけど

521
00:25:46,579 --> 00:25:48,700
普通のハフマン符号化だと

522
00:25:48,700 --> 00:25:50,960
符号の割当には自由度があるんですね

523
00:25:50,960 --> 00:25:53,039
さっきの例だと

524
00:25:53,039 --> 00:25:56,420
同じ出現頻度のRBPの符号の割当は

525
00:25:56,420 --> 00:25:58,200
入れ替えても圧縮率が使わないので

526
00:25:58,200 --> 00:26:00,319
入れ替えてもいいんですよ

527
00:26:00,319 --> 00:26:03,180
でもエンコード結果が符号の割当が変わるので

528
00:26:03,180 --> 00:26:04,519
変わっちゃうんですよね

529
00:26:04,519 --> 00:26:07,839
なので符号化した結果を複合するためには

530
00:26:07,839 --> 00:26:10,460
このキーとかこの符号の表が必要になります

531
00:26:10,460 --> 00:26:13,839
符号表を一緒に送っても

532
00:26:13,839 --> 00:26:15,859
圧縮対象のデータが十分に大きかったら

533
00:26:15,859 --> 00:26:17,440
圧縮の効果はあるんですけど

534
00:26:17,440 --> 00:26:21,220
ルールが決まっているのであれば

535
00:26:21,220 --> 00:26:24,880
符号表を送る必要がないんですね

536
00:26:24,880 --> 00:26:27,900
そういうルールを決めようっていうのが

537
00:26:27,900 --> 00:26:29,480
カノニカルハフマン符号化

538
00:26:29,480 --> 00:26:32,480
正準ハフマンとも言いますけどのことです

539
00:26:32,480 --> 00:26:36,420
カノニカルハフマンのルールはこうです

540
00:26:36,420 --> 00:26:40,200
これも見たほうが早いのでやってみましょう

541
00:26:40,200 --> 00:26:48,359
要は同じ長さの符号のうちでシンボルを相当して連番をつけるということです

542
00:26:48,359 --> 00:26:51,599
木をルートからたどると符号になるということは

543
00:26:51,599 --> 00:26:54,440
符号の長さというのは木の深さですね

544
00:26:54,440 --> 00:26:59,880
同じ深さのシンボルを辞書順に並べ替えます

545
00:26:59,880 --> 00:27:06,940
同じ長さのグループに対して連番になるように符号をつけるということです

546
00:27:06,940 --> 00:27:08,039
こういうルール

547
00:27:08,039 --> 00:27:10,599
カノニカルハフマンというのはこのルールでつけるので

548
00:27:10,599 --> 00:27:13,460
木とか符号表を共有する必要がないんですね

549
00:27:13,460 --> 00:27:14,920
デコードに必要なのは

550
00:27:14,920 --> 00:27:19,579
シンボル順に並んだ符号の長さというのを送るだけでいいです

551
00:27:19,579 --> 00:27:23,799
という仕組みがカノニカルハフマン符号化です

552
00:27:23,799 --> 00:27:27,220
デコードするにはだから

553
00:27:27,220 --> 00:27:31,440
シンボル順に並んだ符号の長さの列っていうのを送るんですよね

554
00:27:31,440 --> 00:27:38,680
シンボル順は分かっているんで符号の長さだけにできるんですけど

555
00:27:38,680 --> 00:27:43,880
カノニカルでないハーフマン符号化を符号するには

556
00:27:43,880 --> 00:27:47,039
木の形の葉を送るんですけど

557
00:27:47,039 --> 00:27:51,380
一見するとこれカノニカルハーフマンの方が送りデータ増えてるんですよね

558
00:27:51,380 --> 00:27:56,359
使われる記号が増えるとコスト逆転するんですけど

559
00:27:56,359 --> 00:27:58,660
論点はそれではなくて

560
00:27:58,660 --> 00:28:01,859
カノニカルハフマン不合化の優れてる点は

561
00:28:01,859 --> 00:28:03,640
この不合調の列を見るとですね

562
00:28:03,640 --> 00:28:06,220
大体の要素ゼロなんですよ

563
00:28:06,220 --> 00:28:07,599
それ以外の要素も

564
00:28:07,599 --> 00:28:09,500
これ分かりやすい例なんですけど

565
00:28:09,500 --> 00:28:12,059
2と3しかないんですね

566
00:28:12,059 --> 00:28:13,680
不合調を送ればいいっていうのは

567
00:28:13,680 --> 00:28:16,119
こういうふうにハフマン不合化の有利なデータに

568
00:28:16,119 --> 00:28:18,359
変換できたっていうことになるんですよ

569
00:28:18,359 --> 00:28:19,799
実際にWebPだと

570
00:28:19,799 --> 00:28:23,599
この不合調をさらにハフマン不合化で圧縮するんですね

571
00:28:23,599 --> 00:28:28,900
WebPの符号化で使われる符号の長さというのは最大でも15なんで

572
00:28:28,900 --> 00:28:32,200
ピクセルの取る値のバリエーションと比べたらすごい小さくて

573
00:28:32,200 --> 00:28:35,240
分母が小さい数字にギュッと集まるんですよ

574
00:28:35,240 --> 00:28:38,299
あとこの未使用のゼロというのもたくさん出てくるので

575
00:28:38,299 --> 00:28:40,819
これ非常に圧縮効果が高いという感じで

576
00:28:40,819 --> 00:28:43,500
こういうデータを作りたかったというのが

577
00:28:43,500 --> 00:28:47,220
カノニカルハフマンコーニングの真の目的みたいなことになります

578
00:28:47,220 --> 00:28:50,259
カノニカルハフマンじゃない

579
00:28:50,259 --> 00:28:52,440
ハフマン符号化についてまとめますと

580
00:28:52,440 --> 00:28:55,279
出現頻度の偏りを利用した圧縮で

581
00:28:55,279 --> 00:28:58,500
WebPではカノニカルハフマン不合化が使われて

582
00:28:58,500 --> 00:29:00,940
カノニカルハフマン不合化っていうのは

583
00:29:00,940 --> 00:29:03,980
不合調が分かればデコードできるっていう方式です

584
00:29:03,980 --> 00:29:06,500
不合調の列っていうのは

585
00:29:06,500 --> 00:29:08,759
ハフマン不合化なし効果とかが高いんで

586
00:29:08,759 --> 00:29:13,000
WebPでは不合調の列もハフマン不合化されると

587
00:29:13,000 --> 00:29:14,839
多段というか2回出てくる

588
00:29:14,839 --> 00:29:18,940
これが難しいところの一つでもあるし

589
00:29:18,940 --> 00:29:21,079
重要な点でもあります

590
00:29:21,079 --> 00:29:26,819
ミクロの観点だと同じようなデータを複数回ハフマン不合化するんで

591
00:29:26,819 --> 00:29:29,380
ちょっと今何をしているのかって分かりにくくなる

592
00:29:29,380 --> 00:29:32,279
本当にこれ迷うんですよ書いてて

593
00:29:32,279 --> 00:29:32,980
でのが一つ

594
00:29:32,980 --> 00:29:36,500
あとマクロではこのWebPの工程っていうのは

595
00:29:36,500 --> 00:29:39,839
要はハフマン不合化が絶対かかるんで

596
00:29:39,839 --> 00:29:44,420
ハフマン不合化の効果を最大限発揮するために

597
00:29:44,420 --> 00:29:49,299
WebPの処理ってのは全部ハフマン不合化のために行われていると考えても

598
00:29:49,299 --> 00:29:50,779
そんなに間違いじゃないということです

599
00:29:50,779 --> 00:29:55,220
どうすればハフマン不合化が最終的にかかるので

600
00:29:55,220 --> 00:29:57,359
それまでに復元できる範囲で

601
00:29:57,359 --> 00:30:02,079
ハフマン不合化に最も有利な形になるかということをやっているというのがVPです

602
00:30:02,079 --> 00:30:04,039
ということを理解すると

603
00:30:04,039 --> 00:30:09,240
ややこしいVPの仕組みの処理というのもだんだん見えてくるようになります

604
00:30:09,240 --> 00:30:14,380
実際の画像にハフマン不合化をやってみるとどうなるか

605
00:30:14,380 --> 00:30:17,240
これ感覚なんですけど

606
00:30:17,240 --> 00:30:21,859
VP8Lでは内部的に画像RGBAの4チャンネルなので

607
00:30:21,859 --> 00:30:26,259
それ各成分ごとにハーフマンを合格するんですね

608
00:30:26,259 --> 00:30:31,400
出現回数というのはRGBAそれぞれの成分の出現頻度で

609
00:30:31,400 --> 00:30:35,119
例えば緑の成分について考えると

610
00:30:35,119 --> 00:30:40,920
出現する成分がこうなって頻度はこうなると

611
00:30:40,920 --> 00:30:45,460
めっちゃ使われている206を短いシンボルにして

612
00:30:45,460 --> 00:30:46,019
符号にして

613
00:30:46,019 --> 00:30:49,380
0、66、100は長い

614
00:30:49,380 --> 00:30:51,400
符号にするのがハフマン符号化です

615
00:30:51,400 --> 00:30:55,140
何も前処理していない

616
00:30:55,140 --> 00:30:56,740
ただのタバの画像を

617
00:30:56,740 --> 00:30:58,740
ハフマン符号化する場合でも

618
00:30:58,740 --> 00:31:00,480
これ見たら分かったのに

619
00:31:00,480 --> 00:31:01,240
成分ごとに分けたら

620
00:31:01,240 --> 00:31:02,759
結構使ってないシンボルとか

621
00:31:02,759 --> 00:31:04,460
偏りがあるんですよ

622
00:31:04,460 --> 00:31:07,559
あるんですごい圧縮できるんですよ

623
00:31:07,559 --> 00:31:08,900
符号化はこうなって

624
00:31:08,900 --> 00:31:11,079
206とかはもう0だけで

625
00:31:11,079 --> 00:31:12,819
表現できるんで

626
00:31:12,819 --> 00:31:14,559
ギュッと減るんですね

627
00:31:14,559 --> 00:31:18,119
実際にこれ実際の画像のサイズです

628
00:31:18,119 --> 00:31:21,420
この16×16なんでサイズ小さいし

629
00:31:21,420 --> 00:31:25,700
実際の画像で行われるのとは結構ガラッと変わるんですけど

630
00:31:25,700 --> 00:31:29,880
それでも無圧縮だと1302バイトあるんですけど

631
00:31:29,880 --> 00:31:33,759
単純なハフマンを動かすだけで384バイトになるという感じです

632
00:31:33,759 --> 00:31:39,839
実際はこれをさらに効きやすくするために変換を行うので

633
00:31:39,839 --> 00:31:42,240
このグリーンだけさっき見たよりも

634
00:31:42,240 --> 00:31:45,700
それがさっきグリーンだけで見た場合でもギュッと圧縮できるんですけど

635
00:31:45,700 --> 00:31:48,980
もっと圧縮できるみたいなことになります

636
00:31:48,980 --> 00:31:52,460
一旦ハフマン不効果を改めてまとめると

637
00:31:52,460 --> 00:31:59,319
実際の画像のデータはだいたい使ったシンボルもあるし

638
00:31:59,319 --> 00:32:04,240
水分で分けるとかなりRGBで分けると偏りがあるので

639
00:32:04,240 --> 00:32:06,400
ハフマン不効果がよく効くんですね

640
00:32:06,400 --> 00:32:10,980
さらにWebPではハフマン不効果の効果を高めるために

641
00:32:10,980 --> 00:32:14,140
あらゆる変換というのをその前工程で行うというのがWEPPです

642
00:32:14,140 --> 00:32:18,440
ハフマン保護化だけは必須の工程で

643
00:32:18,440 --> 00:32:19,980
ハフマン保護化していないデータというのは

644
00:32:19,980 --> 00:32:23,920
WEPPとは認識されないです

645
00:32:23,920 --> 00:32:26,099
なのでなんですけどだからか

646
00:32:26,099 --> 00:32:28,259
だからハフマン保護化だけできたら

647
00:32:28,259 --> 00:32:30,880
企画としては正しいWEPP

648
00:32:30,880 --> 00:32:34,619
他のビューアーでもWEPPとして読み込めるファイルができます

649
00:32:34,619 --> 00:32:39,079
ハフマン保護化は2回以上出てくるので

650
00:32:39,079 --> 00:32:40,660
そこ分かりにくいんですけど

651
00:32:40,660 --> 00:32:45,980
ここが実装できたらあとは一個ずつ順番に結構実装していくことになるので

652
00:32:45,980 --> 00:32:50,359
これを実装してしまえば実は結構ゴールはすぐみたいな感じになります

653
00:32:50,359 --> 00:32:55,019
ここでですねもう一回エンコーディングの工程見直してくるとですね

654
00:32:55,019 --> 00:32:57,539
ちょっと前より見えてくるんじゃないかなと思うんですよ

655
00:32:57,539 --> 00:33:01,319
必須の工程はこの赤色のハフマンコーディングだけで

656
00:33:01,319 --> 00:33:05,380
あとこれとヘッダーがあれば基本的にWEPPの画像として認識できるものできます

657
00:33:05,380 --> 00:33:08,900
この緑の工程やらなくてもWEPPの画像を作るだけだったらOKです

658
00:33:08,900 --> 00:33:11,640
緑は処理は任意で

659
00:33:11,640 --> 00:33:14,859
これはハフマン不合化の効果を高くするための

660
00:33:14,859 --> 00:33:16,859
前処理っていうものです

661
00:33:16,859 --> 00:33:18,319
ということですね

662
00:33:18,319 --> 00:33:21,200
残りの緑の処理っていうのをここから見ていくことになります

663
00:33:21,200 --> 00:33:24,000
まずサブトラクトグリーン

664
00:33:24,000 --> 00:33:27,779
緑を基準に無駄を引く

665
00:33:27,779 --> 00:33:33,279
ハフマン不合化ができたら

666
00:33:33,279 --> 00:33:35,799
次はこれをやるのがおすすめです

667
00:33:35,799 --> 00:33:43,220
これはカッコとピクセルで赤と青の成分から緑を引いて

668
00:33:43,220 --> 00:33:47,299
色成分の相関を下げて圧縮が引くようにするという変換です

669
00:33:47,299 --> 00:33:50,400
これはもう本当に引くだけなのですごい簡単なので

670
00:33:50,400 --> 00:33:52,700
これをやるこれは簡単です

671
00:33:52,700 --> 00:33:55,480
本当にレッドとブルーからグリーンを引くだけです

672
00:33:55,480 --> 00:33:58,579
アンダーフローした場合はラップアラウンドして戻ってきます

673
00:33:58,579 --> 00:34:01,900
なんでグリーンを引くかというと

674
00:34:01,900 --> 00:34:04,740
大抵の画像は明るさと色に分けて考える

675
00:34:04,740 --> 00:34:07,980
明るさが大体すごい大きくて

676
00:34:07,980 --> 00:34:09,239
色の差というのは小さいんですよ

677
00:34:09,239 --> 00:34:10,699
だから明るさを下げたい

678
00:34:10,699 --> 00:34:15,880
緑は人間の知覚としては明るさを感じられやすいので

679
00:34:15,880 --> 00:34:17,860
基本的な色空間だったら

680
00:34:17,860 --> 00:34:20,320
緑成分は明るさの方に多いんですよ

681
00:34:20,320 --> 00:34:23,940
なので緑を赤と青から引くと

682
00:34:23,940 --> 00:34:26,159
共通で持っている明るさというのが打ち消されて

683
00:34:26,159 --> 00:34:28,019
色の差だけが残るんですね

684
00:34:28,019 --> 00:34:31,539
色の差というのはそんなに普通は大きくないので

685
00:34:31,539 --> 00:34:34,440
そうすると分布がギュッと集まって

686
00:34:34,440 --> 00:34:36,300
圧縮しやすくなるという仕組みです

687
00:34:36,300 --> 00:34:38,019
デコードは逆

688
00:34:38,019 --> 00:34:41,079
赤とブルーからグリーンは引くけど

689
00:34:41,079 --> 00:34:42,760
グリーンはそのまま残っているので

690
00:34:42,760 --> 00:34:45,960
デコードするときは残っているグリーンを足すだけです

691
00:34:45,960 --> 00:34:47,559
簡単ですね

692
00:34:47,559 --> 00:34:52,880
こういうのをよくできているなと後の工程でも思うんですけど

693
00:34:52,880 --> 00:34:57,659
グリーン残っているからそのままそれを使って足せばいいんだというのを

694
00:34:57,659 --> 00:34:59,579
ちょっと面白いかなと私は思うんですけど

695
00:34:59,579 --> 00:35:02,940
これちょっと実際に効果を確認してみましょう

696
00:35:02,940 --> 00:35:07,960
こういうグレーっぽいやつによく聞くんですよ

697
00:35:07,960 --> 00:35:10,840
っていうのはグレーっていうのは基本的に明るさがほとんどなんで

698
00:35:10,840 --> 00:35:13,340
本当にグレースケールだったらサブトラクトグリーンしたら

699
00:35:13,340 --> 00:35:14,340
これ全部ゼロになります

700
00:35:14,340 --> 00:35:18,679
これRGBの数字がこんな形になっていて

701
00:35:18,679 --> 00:35:19,860
実際にこのイルです

702
00:35:19,860 --> 00:35:24,119
これ赤と青からグリーンを引くと

703
00:35:24,119 --> 00:35:28,559
大体の数字が-3から6までっていう非常にすごい小さい値になって

704
00:35:28,559 --> 00:35:31,000
分布がゼロ付近にギュッと寄るんですよ

705
00:35:31,000 --> 00:35:35,639
そういう状態になるとハーフマン効果がめちゃくちゃ効くようになるんですね

706
00:35:35,639 --> 00:35:39,320
っていうのがサブストラクトグリーンという前処理

707
00:35:39,320 --> 00:35:42,320
つまり画像全体に効くわけじゃないんだけど

708
00:35:42,320 --> 00:35:44,900
こういう地面の色だったりとか

709
00:35:44,900 --> 00:35:46,519
あと曇り空の色とかあったら

710
00:35:46,519 --> 00:35:50,059
こういうのが連続している空間というのは絶対出てくるので

711
00:35:50,059 --> 00:35:54,420
そういう画像の時にはめっちゃ効くみたいな前処理になります

712
00:35:54,420 --> 00:35:58,460
もう一つ使われているのでLZ7ですね

713
00:35:58,460 --> 00:36:03,420
これ同じパターンの繰り返しを距離と長さで表すことで圧縮する仕組みです

714
00:36:03,420 --> 00:36:07,920
この画像をLZ77でエンコードする場合は

715
00:36:07,920 --> 00:36:14,079
読んでいく最中に連続するパターンがあったら記録していくんですね

716
00:36:14,079 --> 00:36:17,099
キャッシュみたいな感じで

717
00:36:17,099 --> 00:36:21,340
読んでいくたびにこれ過去のパターンと一致しているかどうかなというのを見ていって

718
00:36:21,340 --> 00:36:24,460
全部のピクセルでやっているとすごい時間がかかるので

719
00:36:24,460 --> 00:36:27,400
基本的には3ピクセルごとで飛ばして読んでいくという感じになります

720
00:36:27,400 --> 00:36:31,820
3ピクセルなのは規格で圧縮長さは3以上って決まっているので

721
00:36:31,820 --> 00:36:34,360
そうやって読んだら一番効率がいいみたいな感じですね

722
00:36:34,360 --> 00:36:36,900
パターンと同じものが出てきたら

723
00:36:36,900 --> 00:36:39,820
このパターンがどれだけ続くかというのを

724
00:36:39,820 --> 00:36:41,039
続く限りずっと進めて

725
00:36:41,039 --> 00:36:43,400
パターンのレンズが途切れたところがあると

726
00:36:43,400 --> 00:36:47,400
これは15個前のピクセルから

727
00:36:47,400 --> 00:36:51,900
5個先までは同じパターンがきますという風な記録をします

728
00:36:51,900 --> 00:36:58,539
これがだから153という別の表現に置き換えることができるって感じですね

729
00:36:58,539 --> 00:37:01,480
こういうのがLZ7です

730
00:37:01,480 --> 00:37:05,139
これはハフマン不合化のための変換というよりかは

731
00:37:05,139 --> 00:37:09,119
ハフマン不合化で圧縮できない感じのもの

732
00:37:09,119 --> 00:37:12,000
ハフマン不合化は分布の過程より圧縮するんですけど

733
00:37:12,000 --> 00:37:14,440
それだと繰り返しとかパターンというのは

734
00:37:14,440 --> 00:37:17,079
ハフマン不合化では効いてこないので

735
00:37:17,079 --> 00:37:21,000
ハフマン不合化で効いてこない繰り返しとかパターンを圧縮するために

736
00:37:21,000 --> 00:37:23,440
あるっていうのが補完的にある

737
00:37:23,440 --> 00:37:25,340
圧縮方法みたいな感じですね

738
00:37:25,340 --> 00:37:26,360
LZ77は

739
00:37:26,360 --> 00:37:30,159
次プレディクトトランスフォーム

740
00:37:30,159 --> 00:37:32,559
これ隣の上で次の色当てる

741
00:37:32,559 --> 00:37:37,340
左と左上の隣に合っているピクセルを使って

742
00:37:37,340 --> 00:37:38,360
現代のピクセルが

743
00:37:38,360 --> 00:37:40,360
だいたい近い辺りが来るんで

744
00:37:40,360 --> 00:37:43,480
そのピクセル何かなっていうのを予測して

745
00:37:43,480 --> 00:37:45,639
予測したものと差だけを

746
00:37:45,639 --> 00:37:49,559
差を取ってその差だけを記録するっていう変換です

747
00:37:49,559 --> 00:37:53,639
例えば暗い部分まで今ピクセルを読んでて

748
00:37:53,639 --> 00:37:54,619
エンコード済みで

749
00:37:54,619 --> 00:37:57,039
次この赤く囲った部分を読んで

750
00:37:57,039 --> 00:37:58,579
エンコードしようとしているときに

751
00:37:58,579 --> 00:38:01,800
このピクセルが何かなっていうのを

752
00:38:01,800 --> 00:38:04,639
この隣り合った左と左上と上のピクセルから

753
00:38:04,639 --> 00:38:05,500
予測するんですよね

754
00:38:05,500 --> 00:38:06,639
予測するって言っても

755
00:38:06,639 --> 00:38:09,800
予測が当たるかどうかはどうでもいいんですよ

756
00:38:09,800 --> 00:38:14,119
要は差を取って値を小さくしたいってことなんですよね

757
00:38:14,119 --> 00:38:16,139
そうすると分布が集まるんで

758
00:38:16,139 --> 00:38:19,880
でもできるだけだから予測は近い方がいいんですけど

759
00:38:19,880 --> 00:38:23,380
というのでそういうそれっぽい

760
00:38:23,380 --> 00:38:24,719
経験的じゃないけど

761
00:38:24,719 --> 00:38:27,000
それっぽく近くなるような関数というのが

762
00:38:27,000 --> 00:38:29,039
あらかじめ規格で14スリー決まっていて

763
00:38:29,039 --> 00:38:30,480
それを適用していて

764
00:38:30,480 --> 00:38:33,139
一番いいやつを当てるみたいな感じです

765
00:38:33,139 --> 00:38:34,760
要は何でもいいっちゃ

766
00:38:34,760 --> 00:38:37,000
何でもいいんで何でもいい値で

767
00:38:37,000 --> 00:38:39,159
何か引いて小さくなればいいと

768
00:38:39,159 --> 00:38:41,420
当然この関数は共有されているので

769
00:38:41,420 --> 00:38:43,900
デコーダーの方も同じ関数を使って

770
00:38:43,900 --> 00:38:45,519
デコードすることができるということです

771
00:38:45,519 --> 00:38:49,960
クロスカラーは色同士の混ざりを解いて

772
00:38:49,960 --> 00:38:52,300
赤や青の揺れを小さくする

773
00:38:52,300 --> 00:38:54,699
これどういうことかというと

774
00:38:54,699 --> 00:38:57,960
やることはちょっとブロックに区切って

775
00:38:57,960 --> 00:38:59,440
そこで係数をかけて

776
00:38:59,440 --> 00:39:03,800
結局RとBからまたグリーンを引くみたいなことなんですけど

777
00:39:03,800 --> 00:39:06,579
サブトラックとグリーンと違って

778
00:39:06,579 --> 00:39:11,420
もうちょっと小さい色の揺れを減らす感じですね

779
00:39:11,420 --> 00:39:15,780
芝生とか日本人の肌の色みたいな感じで

780
00:39:15,780 --> 00:39:19,860
色がちょっとチカチカチカチカっと混ざっているような

781
00:39:19,860 --> 00:39:25,960
画像のときに結構ギュッと文部活動みたいな効果があります

782
00:39:25,960 --> 00:39:28,760
色が滲んでいるみたいな部分ですね

783
00:39:28,760 --> 00:39:30,860
そういうところに効くって感じですね

784
00:39:30,860 --> 00:39:33,480
あとカラーインデックスは

785
00:39:33,480 --> 00:39:37,219
画像に使われている色が256以下のときに

786
00:39:37,219 --> 00:39:40,559
色に番号を振ってその番号で書くっていう感じです

787
00:39:40,559 --> 00:39:43,840
これは256以下だったら使える

788
00:39:43,840 --> 00:39:46,860
結構奥の手みたいな圧縮で

789
00:39:46,860 --> 00:39:48,719
色を全部番号で変えるんで

790
00:39:48,719 --> 00:39:50,480
色が書いてあるところが

791
00:39:50,480 --> 00:39:59,079
すごいギュッと情報量が減るんでっていう圧縮ですね

792
00:39:59,079 --> 00:40:01,440
あとカラーキャッシュ最後ですけど

793
00:40:01,440 --> 00:40:02,679
これ面白くて

794
00:40:02,679 --> 00:40:04,500
一度出てきた色をキャッシュしておいて

795
00:40:04,500 --> 00:40:06,920
同じ色が出てきたらキャッシュのインデックスだけを残す

796
00:40:06,920 --> 00:40:09,300
これやってることはローカルキャッシュで

797
00:40:09,300 --> 00:40:10,820
メモリキャッシュで

798
00:40:10,820 --> 00:40:12,860
ローカル

799
00:40:12,860 --> 00:40:14,980
出てきたものをキャッシュに入れて

800
00:40:14,980 --> 00:40:17,480
なんか次キャッシュに入っているものがあったら

801
00:40:17,480 --> 00:40:18,820
そのキャッシュのインデックスだけ送ると

802
00:40:18,820 --> 00:40:20,559
これローカルキャッシュじゃんって

803
00:40:20,559 --> 00:40:23,460
ローカルキャッシュの情報を送ったところで

804
00:40:23,460 --> 00:40:23,639
これ

805
00:40:23,639 --> 00:40:27,460
相手に送っても複合できるわけないじゃん

806
00:40:27,460 --> 00:40:28,079
と思うんですけど

807
00:40:28,079 --> 00:40:30,980
デコードが同じことができるんですね

808
00:40:30,980 --> 00:40:32,340
エンコードしていって

809
00:40:32,340 --> 00:40:35,059
エンコードしていったやつをキャッシュに入れるわけですよ

810
00:40:35,059 --> 00:40:36,599
デコードか

811
00:40:36,599 --> 00:40:39,280
デコードしていってデコードゼムのものをキャッシュに入れていくんですよ

812
00:40:39,280 --> 00:40:41,179
そしたらエンコード済むので

813
00:40:41,179 --> 00:40:43,159
これキャッシュから入ってるよって情報が来たら

814
00:40:43,159 --> 00:40:45,920
キャッシュに入ってるんでそこから取れるんですよ

815
00:40:45,920 --> 00:40:48,019
これすごい面白いなと思って

816
00:40:48,019 --> 00:40:51,559
もちろんキャッシュの作り方っていうのは

817
00:40:51,559 --> 00:40:52,679
それとおきつあるんですけど

818
00:40:52,679 --> 00:40:54,739
ローカルキャッシュなんだけど

819
00:40:54,739 --> 00:40:57,039
順々に読んでいくものっていうのは一緒だから

820
00:40:57,039 --> 00:41:00,840
キャッシュのインデックスだけで複合できるっていうのは

821
00:41:00,840 --> 00:41:01,980
これすごい面白いなと思って

822
00:41:01,980 --> 00:41:03,639
これよくできてるなと思う

823
00:41:03,639 --> 00:41:04,579
アッシュ方式ですね

824
00:41:04,579 --> 00:41:07,360
でも簡単なんで実装は簡単です

825
00:41:07,360 --> 00:41:13,219
ということでまとめ結構面白かったと思ってもらえたらいいなと思うんですけど

826
00:41:13,219 --> 00:41:17,139
FPEの原理と仕組みちょっとかいつまんで説明しました

827
00:41:17,139 --> 00:41:19,780
かっこいいUIのコードとかではないので

828
00:41:19,780 --> 00:41:22,880
今すぐやってみようというのはそんなにならないと思うんですけど

829
00:41:22,880 --> 00:41:25,400
画像を圧縮する仕組み

830
00:41:25,400 --> 00:41:29,400
特に今見たロスエスアクショクというのは結構合理性を追求した

831
00:41:29,400 --> 00:41:33,420
美しい仕組みと思ってもらえたら嬉しいなと思います

832
00:41:33,420 --> 00:41:37,059
データ圧縮の考え方はこの画像だけじゃなくて

833
00:41:37,059 --> 00:41:38,780
いろんなデータ処理に効いてくるので

834
00:41:38,780 --> 00:41:41,940
一回触れていろんな手法があるというのを覚えておいたら

835
00:41:41,940 --> 00:41:43,980
いろいろ視界が広がる領域じゃないかなと思います

836
00:41:43,980 --> 00:41:46,619
次のステップとしては

837
00:41:46,619 --> 00:41:48,880
サンプルで提供しているエンコーダーを

838
00:41:48,880 --> 00:41:50,800
ちょっと最適化していくのがいいんじゃないかと思います

839
00:41:50,800 --> 00:41:54,400
サンプルはエンコーダーはほとんどの種類が

840
00:41:54,400 --> 00:41:55,780
一種類の固定になっていて

841
00:41:55,780 --> 00:41:57,639
本当はエンコーダーというのは

842
00:41:57,639 --> 00:42:00,500
画像によってどんな変換を適用するのか

843
00:42:00,500 --> 00:42:02,960
変えたりとかパラメータ調整したりとかして

844
00:42:02,960 --> 00:42:05,019
より小さくなるということをするので

845
00:42:05,019 --> 00:42:09,519
そういうことをしていろいろ変えてみたりとかして

846
00:42:09,519 --> 00:42:11,159
結果を測って比べたり

847
00:42:11,159 --> 00:42:14,219
大小さくなったとかもあったら結構新しい発見があって

848
00:42:14,219 --> 00:42:15,119
面白いんじゃないかなと

849
00:42:15,119 --> 00:42:18,019
そういう仮説を立てて実行して検証するというのは

850
00:42:18,019 --> 00:42:20,179
相対の改善の王道なんで

851
00:42:20,179 --> 00:42:23,000
そういうサイクルをじっくりやってみるというのが

852
00:42:23,000 --> 00:42:24,880
いいんじゃないかなと思います

853
00:42:24,880 --> 00:42:29,039
今回の話がちょっとでも面白そうだなと思ってもらえたら

854
00:42:29,039 --> 00:42:30,360
嬉しいです

855
00:42:30,360 --> 00:42:31,400
どうもありがとうございました

856
00:42:35,019 --> 00:42:40,280
発表ありがとうございました

857
00:42:40,280 --> 00:42:43,800
それではQ&Aに入りたいと思います

858
00:42:43,800 --> 00:42:47,119
コメントやご質問のある方は手を挙げてお知らせください

859
00:42:47,119 --> 00:42:58,980
はいではQ&A終了させていただきます

860
00:42:58,980 --> 00:43:02,119
続いて1分間フィードバックのお時間です

861
00:43:05,019 --> 00:43:12,280
1分間フィードバックのお時間です

862
00:43:12,280 --> 00:43:15,280
スクリーンのQRコードを読み取って

863
00:43:15,280 --> 00:43:17,219
フィードバックを送ってください

